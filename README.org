#+TITLE: PGF in Racket

This repository contains various experiments used during the development of the Pretty Good Formatter (PGF) pipeline, written in Racket. This codebase is particularly focused on developing variations of Wadler's "prettier printer" algorithm. It is a step-by-step derivation from the original Haskell implementation, first a fairly faithful adaptation, then diverging to be easier to implement in more traditional-style languages (such as Rascal and Java), and finally being further adjusted to better fit the PGF pipeline.

* Variants

  We use Git branches to capture interesting snapshots of the codebase to allow them to be separately maintained if desired. The =master= branch merely contains shared documentation.

** =haskellish=

  This "Haskellish" variant aims to be a faithful adaptation of Philip Wadler's pretty printer to Racket. In fact it's such a straightforward translation of the Haskell code listing given in Wadler's paper [1] that it may be covered by Wadler's copyright. The goal here is to make the Racket port such that anyone comparing it against what is given in Wadler's paper would be convinced that it implements the same algorithm.

  In my opinion the Racket code reads much the same as the Haskell code. The Racket version defines some custom macros to enable this. The remaining differences in the way the code reads is that the Racket version is not using overloading or pattern matching, which are somewhat atypical in Scheme code, and also that laziness is somewhat more explicit in the Racket code, but not overly so.

  Racket includes the =match= pattern matcher and also a =struct*= pattern form which we could have used, but given that the patterns used in the Haskell code were rather simple, we feel that this would not have given enough benefit to make up for the loss of idiomatic Scheme. We could have also devised some kind of multimethods with pattern-based dynamic dispatch, but given the fixed set of pretty printing primitives this also didn't seem worthwhile, and we're simply doing our "dispatch" within functions using =cond= and other conditional expressions.

  The most significant difference while translating was Haskell's lazy evaluation semantics vs. Racket's strict evaluation semantics. Had we not used promises to address this issue it would have destroyed the performance of the Racket version; for instance formatting this document with the Racket version would not have been feasible. Hence we added "even" laziness to all the right places without completely overhauling the Racket code. Our approach is based on Wadler's own paper on laziness [2].

** =rascalish=

   This "Rascalish" variant was produced from the Haskellish one. What was necessary in this "port" was to deal with paradigm differences, involving things such as implementing laziness explicitly, and replacing deep recursion with loops. We then produced a Rascal port based on this code, basically by just dealing with superficial language differences, and library differences.

** =pgf_groupings=

   This variant builds extensions onto the Rascalish variant of the codebase. The most notable extension is support for "groupings", which allows for operations such as =group= and =flatten= (and anything, really) to be represented as tokens within token sequences.

* License

  Except where otherwise noted, all code is authored by Tero Hasu, copyright University of Bergen, and not licensed for distribution at this time.

* References

[1] Philip Wadler. A prettier printer. The Fun of Programming. A
    symposium in honour of Professor Richard Bird's 60th birthday
    Examination Schools, Oxford, 24-25 March 2003. (Original paper
    April 1997, revised March 1998.)

[2] Philip Wadler, Walid Taha, and David MacQueen. How to add laziness
    to a strict language, without even being odd. Workshop on Standard
    ML, Baltimore, September 1998.
